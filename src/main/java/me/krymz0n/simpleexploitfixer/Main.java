package me.krymz0n.simpleexploitfixer;

import com.comphenix.protocol.ProtocolManager;
import me.krymz0n.simpleexploitfixer.commands.Reload;
import me.krymz0n.simpleexploitfixer.listener.ProtocolLib;
import me.krymz0n.simpleexploitfixer.listener.exploit.BowBomb;
import me.krymz0n.simpleexploitfixer.listener.exploit.Log4J;
import me.krymz0n.simpleexploitfixer.listener.lag.*;
import me.krymz0n.simpleexploitfixer.listener.misc.Chat;
import me.krymz0n.simpleexploitfixer.listener.misc.CreatureSpawn;
import me.krymz0n.simpleexploitfixer.listener.misc.InteractEvent;
import org.bukkit.Bukkit;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.entity.Bee;
import org.bukkit.entity.Entity;
import org.bukkit.entity.ItemFrame;
import org.bukkit.event.Listener;
import org.bukkit.plugin.PluginManager;
import org.bukkit.plugin.java.JavaPlugin;

import java.util.Objects;

public final class Main extends JavaPlugin implements Listener {
    private static Main instance;
    private ProtocolManager protocolManager;

    @Override
    public void onEnable() {
        saveDefaultConfig();

        // Plugin registries
        PluginManager pm = getServer().getPluginManager();
        pm.registerEvents(this, this);
        pm.registerEvents(new Bees(this), this);
        pm.registerEvents(new CreatureSpawn(this), this);
        pm.registerEvents(new ChunkBan(this), this);
        pm.registerEvents(new WitherSkulls(this), this);
        pm.registerEvents(new InteractEvent(this), this);
        pm.registerEvents(new ArmorStand(this), this);
        pm.registerEvents(new RedstoneLag(this), this);
        pm.registerEvents(new Rail(this), this);
        pm.registerEvents(new Chat(this), this);
        pm.registerEvents(new BowBomb(this), this);
        //pm.registerEvents(new TabComplete(this), this);
        pm.registerEvents(new Log4J(this), this);

        Objects.requireNonNull(getCommand("sef")).setExecutor(new Reload(this));

        if (instance == null) instance = this;

        // Protocol Lib shit
        if (getConfig().getBoolean("DisableAllProtocolLib")) {
            getLogger().info("You specified to disable all ProtocolLib patches.");
        } else {
            if (getServer().getPluginManager().getPlugin("ProtocolLib") != null) {
                getLogger().info("Detected ProtocolLib!");
                ProtocolLib.protocolLibWrapper(this);
            } else {
                getLogger().warning("Did not detect ProtocolLib, disabling packet patches");
            }
        }

        if (getConfig().getBoolean("StrictBeeCheck")) { // This checks for bees more strictly
            Bukkit.getScheduler().runTaskTimerAsynchronously(this, () -> {
                for (World w : Bukkit.getWorlds()) {
                    for (Chunk c : w.getLoadedChunks()) {
                        int count = 0;
                        for (Entity entity : c.getEntities()) {
                            if (entity instanceof Bee) {
                                if (count > getConfig().getInt("MaxBeesPerChunk")) {
                                    entity.remove();
                                }
                                count++;
                            }
                        }
                    }
                }
            }, 0L, 400L);
        }

        /*
        if (getConfig().getBoolean("PreventTooManyEntitiesInChunk")) { // Preventing too much of entities in chunks
            Bukkit.getScheduler().runTaskTimerAsynchronously(this, () -> {
                for (World w : Bukkit.getWorlds()) {
                    for (Chunk c : w.getLoadedChunks()) {
                        int count = 0;
                        for (Entity entity : c.getEntities()) {
                            if (Utils.isEntity(entity) && !(entity instanceof LivingEntity)) {
                                if (count > getConfig().getInt("MaxEntitiesInChunk")) {
                                    entity.remove();
                                    if (getConfig().getBoolean("LogEntityRemovals")) {
                                        getLogger().warning("Removed entity " + entity.getType() + " at " + entity.getLocation() + " because reached entity limit of " + getConfig().getInt("MaxEntitiesInChunk"));
                                    }
                                }
                                count++;
                            }
                        }
                    }
                }
            }, 0L, getConfig().getInt("EntityCheckTimeTicks") * 20L);
        }*/

        if (getConfig().getBoolean("StrictArmorStandCheck")) { // Strict check for Armor stands
            Bukkit.getScheduler().runTaskTimerAsynchronously(this, () -> {
                for (World w : Bukkit.getWorlds()) {
                    for (Chunk c : w.getLoadedChunks()) {
                        int count = 0;
                        for (Entity entity : c.getEntities()) {
                            if (entity instanceof ArmorStand) {
                                if (count > getConfig().getInt("MaxArmorStandPerChunk")) {
                                    entity.remove();
                                }
                                count++;
                            }
                        }
                    }
                }
            }, 0L, 400L);

        }

        if (getConfig().getBoolean("PreventChunkBan")) { // I think a strict check for item frames, but I made it weird? probs gonna fix later
            Bukkit.getScheduler().runTaskTimerAsynchronously(this, () -> {
                for (World w : Bukkit.getWorlds()) {
                    for (Chunk c : w.getLoadedChunks()) {
                        int count = 0;
                        for (Entity entity : c.getEntities()) {
                            if (entity instanceof ItemFrame) {
                                if (count > getConfig().getInt("MaxItemFramePerChunk")) {
                                    entity.remove();
                                }
                                count++;
                            }
                        }
                    }
                }
            }, 0L, 400L);

        }
    }
    public Integer count(Chunk c, Material m ) { // Super cool count feature to count the amount of blocks per chunk.
        int num = 0;
        for (int x = 0; x < 16; x++) {
            for (int z = 0; z < 16; z++) {
                for (int y = 0; y < 256; y++) {
                    if (c.getBlock(x, y, z).getType() == m) {
                        num++;
                    }
                }
            }
        }
        return num;
    }


    @Override
    public void onDisable() {

    }

    public static Main getInstance() {
        return instance;
    }

    public ProtocolManager getProtocolManager() {
        return protocolManager;
    }
}
