package me.krymz0n.simpleexploitfixer;

import me.krymz0n.simpleexploitfixer.commands.Reload;
import me.krymz0n.simpleexploitfixer.listener.*;
import me.krymz0n.simpleexploitfixer.util.ItemUtil;
import org.bstats.bukkit.Metrics;
import org.bukkit.Bukkit;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.entity.Bee;
import org.bukkit.entity.Entity;
import org.bukkit.entity.ItemFrame;
import org.bukkit.entity.LivingEntity;
import org.bukkit.event.Listener;
import org.bukkit.plugin.PluginManager;
import org.bukkit.plugin.java.JavaPlugin;

import java.util.Objects;

public final class Main extends JavaPlugin implements Listener {

    @Override
    public void onEnable() {
        saveDefaultConfig();
        PluginManager pm = getServer().getPluginManager();
        pm.registerEvents(this, this);
        pm.registerEvents(new Bees(this), this);
        pm.registerEvents(new CreatureSpawn(this), this);
        pm.registerEvents(new ChunkBan(this), this);
        pm.registerEvents(new WitherSkulls(this), this);
        pm.registerEvents(new InteractEvent(this), this);
        pm.registerEvents(new ArmorStand(this), this);
        pm.registerEvents(new RedstoneLag(this), this);
        pm.registerEvents(new Rail(this), this);
        pm.registerEvents(new Chat(this), this);
        pm.registerEvents(new TabComplete(this), this);
        pm.registerEvents(new BowBomb(this), this);

        Objects.requireNonNull(getCommand("sef")).setExecutor(new Reload(this));

        if (getConfig().getBoolean("DisableAllProtocolLib")) {
            getLogger().info("You specified to disable all ProtocolLib patches.");
        } else {
            if (getServer().getPluginManager().getPlugin("ProtocolLib") != null) {
                getLogger().info("Detected ProtocolLib!");
                ProtocolLib.protocolLibWrapper(this);
            } else {
                getLogger().warning("Did not detect ProtocolLib, disabling packet patches");
            }
        }

        if (getConfig().getBoolean("StrictBeeCheck")) {
            Bukkit.getScheduler().runTaskTimer(this, () -> {
                for (World w : Bukkit.getWorlds()) {
                    for (Chunk c : w.getLoadedChunks()) {
                        int count = 0;
                        for (Entity entity : c.getEntities()) {
                            if (entity instanceof Bee) {
                                if (count > getConfig().getInt("MaxBeesPerChunk")) {
                                    entity.remove();
                                }
                                count++;
                            }
                        }
                    }
                }
            }, 0L, 200L);

        }

        if (getConfig().getBoolean("PreventTooManyEntitiesInChunk")) {
            Bukkit.getScheduler().runTaskTimer(this, () -> {
                for (World w : Bukkit.getWorlds()) {
                    for (Chunk c : w.getLoadedChunks()) {
                        int count = 0;
                        for (Entity entity : c.getEntities()) {
                            if (ItemUtil.isEntity(entity) && !(entity instanceof LivingEntity)) {
                                if (count > getConfig().getInt("MaxEntitiesInChunk")) {
                                    entity.remove();
                                    if (getConfig().getBoolean("LogEntityRemovals")) {
                                        getLogger().warning("Removed entity " + entity.getType() + " at " + entity.getLocation() + " because reached entity limit of " + getConfig().getInt("MaxEntitiesInChunk"));
                                    }
                                }
                                count++;
                            }
                        }
                    }
                }
            }, 0L, getConfig().getInt("EntityCheckTimeTicks"));
        }

        if (getConfig().getBoolean("StrictArmorStandCheck")) {
            Bukkit.getScheduler().runTaskTimer(this, () -> {
                for (World w : Bukkit.getWorlds()) {
                    for (Chunk c : w.getLoadedChunks()) {
                        int count = 0;
                        for (Entity entity : c.getEntities()) {
                            if (entity instanceof ArmorStand) {
                                if (count > getConfig().getInt("MaxArmorStandPerChunk")) {
                                    entity.remove();
                                }
                                count++;
                            }
                        }
                    }
                }
            }, 0L, 200L);

        }

        if (getConfig().getBoolean("PreventChunkBan")) {
            Bukkit.getScheduler().runTaskTimer(this, () -> {
                for (World w : Bukkit.getWorlds()) {
                    for (Chunk c : w.getLoadedChunks()) {
                        int count = 0;
                        for (Entity entity : c.getEntities()) {
                            if (entity instanceof ItemFrame) {
                                if (count > getConfig().getInt("MaxItemFramePerChunk")) {
                                    entity.remove();
                                }
                                count++;
                            }
                        }
                    }
                }
            }, 0L, 100L);

        }
    }
            public Integer count(Chunk c, Material m ) {
                int num = 0;
                for (int x = 0; x < 16; x++) {
                    for (int z = 0; z < 16; z++) {
                        for (int y = 0; y < 256; y++) {
                            if (c.getBlock(x, y, z).getType() == m) {
                                num++;
                            }
                        }
                    }
                }
                return num;
            }


    @Override
    public void onDisable() {
        // Plugin shutdown logic
    }
}
