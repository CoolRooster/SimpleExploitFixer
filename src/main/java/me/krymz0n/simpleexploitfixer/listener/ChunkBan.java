package me.krymz0n.simpleexploitfixer.listener;

import me.krymz0n.simpleexploitfixer.Main;
import net.kyori.adventure.audience.Audience;
import net.kyori.adventure.text.Component;
import org.bukkit.ChatColor;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.block.Container;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.world.ChunkLoadEvent;

import java.util.ArrayList;

public class ChunkBan implements Listener {
    private final Main plugin;

    public ChunkBan(Main plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onBlockPlace(BlockPlaceEvent evt) {
        if (plugin.getConfig().getBoolean("PreventChunkBan")) {
            Block bl = evt.getBlock();
            Chunk ch = evt.getBlock().getChunk();

            Player p = evt.getPlayer();
            String message = ChatColor.RED + "You have placed the maximum amount of this block per chunk!";

            switch (bl.getType()) {
                case ENCHANTING_TABLE: {
                    if (plugin.count(ch, Material.ENCHANTING_TABLE) > plugin.getConfig().getInt("MaxEnchantingTablePerChunk")) {
                        evt.setCancelled(true);
                        Audience.audience(p).sendActionBar(Component.text(message));
                    }
                    break;
                }
                case ENDER_CHEST: {
                    if (plugin.count(ch, Material.ENDER_CHEST) > plugin.getConfig().getInt("MaxEnderchestPerChunk")) {
                        evt.setCancelled(true);
                        Audience.audience(p).sendActionBar(Component.text(message));
                    }
                    break;
                }
                case HOPPER: {
                    if (plugin.count(ch, Material.HOPPER) > plugin.getConfig().getInt("MaxHopperPerChunk")) {
                        evt.setCancelled(true);
                        Audience.audience(p).sendActionBar(Component.text(message));
                    }
                    break;
                }
                case SLIME_BLOCK: {
                    if (plugin.count(ch, bl.getType()) > plugin.getConfig().getInt("MaxSlimePerChunk")) {
                        evt.setCancelled(true);
                        Audience.audience(p).sendActionBar(Component.text(message));
                    }
                    break;
                }
                case BEACON: {
                    if (plugin.count(ch, bl.getType()) > plugin.getConfig().getInt("MaxBeaconPerChunk")) {
                        evt.setCancelled(true);
                        Audience.audience(p).sendActionBar(Component.text(message));
                    }
                    break;
                }
                case GLOWSTONE: {
                    if ((bl.getType().equals(Material.GLOWSTONE)) && plugin.count(ch, bl.getType()) > plugin.getConfig().getInt("MaxGlowstonePerChunk")) {
                        evt.setCancelled(true);
                        Audience.audience(p).sendActionBar(Component.text(message));
                    }
                    break;
                }
                default: {
                    if (bl.getState() instanceof Container) {
                        if (plugin.count(ch, bl.getType()) > plugin.getConfig().getInt("MaxContainerPerChunk")) {
                            evt.setCancelled(true);
                            Audience.audience(p).sendActionBar(Component.text(message));
                        }
                    }
                    break;
                }
            }
        }
    }

    @EventHandler
    public void onChunkLoad(ChunkLoadEvent evt) {
        if (plugin.getConfig().getBoolean("RemoveChunkBansOnChunkLoad") && !evt.isNewChunk()) {
            Chunk ch = evt.getChunk();
            for (int x = 0; x < 16; x++) {
                for (int z = 0; z < 16; z++) {
                    for (int y = 0; y < 256; y++) {
                        Block bl = evt.getChunk().getBlock(x, y, z);
                        switch (bl.getType()) {
                            case ENCHANTING_TABLE: {
                                if (plugin.getConfig().getBoolean("RemoveEnchantingTablesOnChunkLoad") && evt.getChunk().getBlock(x, y, z).getType().equals(Material.ENCHANTING_TABLE)) {
                                    if (plugin.count(ch, Material.ENCHANTING_TABLE) > plugin.getConfig().getInt("MaxEnchantingTablePerChunk")) {
                                        ch.getBlock(x, y, z).setType(Material.AIR);
                                    }
                                }
                                break;
                            }
                            case ENDER_CHEST: {
                                if (plugin.getConfig().getBoolean("RemoveEnderChestsOnChunkLoad") && evt.getChunk().getBlock(x, y, z).getType().equals(Material.ENDER_CHEST)) {
                                    if (plugin.count(ch, Material.ENDER_CHEST) > plugin.getConfig().getInt("MaxEnderchestPerChunk")) {
                                        ch.getBlock(x, y, z).setType(Material.AIR);
                                    }
                                }
                                break;
                            }
                            case HOPPER: {
                                if (plugin.getConfig().getBoolean("RemoveHoppersOnChunkLoad") && evt.getChunk().getBlock(x, y, z).getType().equals(Material.HOPPER)) {
                                    if (plugin.count(ch, Material.HOPPER) > plugin.getConfig().getInt("MaxHopperPerChunk")) {
                                        ch.getBlock(x, y, z).setType(Material.AIR);
                                    }
                                }
                                break;
                            }
                            case SLIME_BLOCK: {
                                if (plugin.getConfig().getBoolean("RemoveSlimeBlocksOnChunkLoad") && evt.getChunk().getBlock(x, y, z).getType().equals(Material.SLIME_BLOCK)) {
                                    if (plugin.count(ch, bl.getType()) > plugin.getConfig().getInt("MaxSlimePerChunk")) {
                                        ch.getBlock(x, y, z).setType(Material.AIR);
                                    }
                                }
                                break;
                            }
                            case BEACON: {
                                if (plugin.getConfig().getBoolean("RemoveBeaconsOnChunkLoad") && evt.getChunk().getBlock(x, y, z).getType().equals(Material.BEACON)) {
                                    if (plugin.count(ch, bl.getType()) > plugin.getConfig().getInt("MaxBeaconPerChunk")) {
                                        ch.getBlock(x, y, z).setType(Material.AIR);
                                    }
                                }
                                break;
                            }
                            case GLOWSTONE: {
                                if (plugin.getConfig().getBoolean("RemoveGlowStoneOnChunkLoad") && evt.getChunk().getBlock(x, y, z).getType().equals(Material.GLOWSTONE)) {
                                    if ((bl.getType().equals(Material.GLOWSTONE)) && plugin.count(ch, bl.getType()) > plugin.getConfig().getInt("MaxGlowstonePerChunk")) {
                                        ch.getBlock(x, y, z).setType(Material.AIR);
                                    }
                                }
                                break;
                            }
                            default: {
                                if (plugin.getConfig().getBoolean("RemoveContainersOnChunkLoad")) {
                                    if (bl.getState() instanceof Container) {
                                        if (plugin.count(ch, bl.getType()) > plugin.getConfig().getInt("MaxContainerPerChunk")) {
                                            ch.getBlock(x, y, z).setType(Material.AIR);
                                        }
                                    }
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
}
